### 복잡한 현실을 단순화 하는 추상화?

추상화는 현실의 복잡함을 극복하기 위한 단순화 인지 방법이다.
현실의 복잡함을 추상화하는 예시와 이점을 알아보자.

최초의 지하철 노선도는 승강장 간의 거리,실제 지형의 묘사로 사실적인 표현방식을 하였는데,
오히려 이런 사실적 정보가 승객들로 하여금 노선도를 이해하기 어렵게만들었다.

승객의 목적이 지형의 정확한 정보가 아닌 최대한 빠르게 목적지에 도착하는것을 기반으로 만들어진
1933년 해리 백이 제시한 노선도는 사실적인 지형에 대한 정보를 전부 무시하고 역 사이의 연결점을 강조하여 
승객이 목적지에 빠르게 도착하기위해 필요한 정보만을 다룬다.

    복잡한 현실의 사실적인 묘사로 불필요한 정보를 제공하는것이 아닌
    승객의 목적에만 집중하여 역과 역 사이의 연결점을 추상화함.

현대의 노선도 묘사방식 또한 1933년 해리 백 이라는 인물이 제시한 방식에서 크게 다른점이 없다.
지형에 대한 사실적인 정보가 아닌 승객이 하차해야하는 승강장의 이름과, 환승구간같이 목적지에 빠르게 도착하기 위한 
역과 역 사이의 직관적인 연결성에 대한 정보를 필요로 하고있다.


해리 백은 승객에게 필요한 정보만을 정확하게 전달하고 불필요한 정보들은 제거함으로써,
사실적이지만 불필요한 정보의 과다로 복잡해진 기존의 노선도와 다르게 추상화를 통해
이해가 쉽고 단순하지만 목적에는 부합한 새로운 노선도를 창조한 것이다.

>추상화는 불필요한 사실을 무시하여 현실의 복잡성을 극복하는데 목적을 두고있으며,
>인간의 복잡한 현실을 단순화하는 가장 기본적인 인지수단이다.

해리 백의 노선도를 이용해 실제 지하철 승강장의 위치를 알아기에는 
추상화를통해 왜곡된 지형정보가 굉장히 부적합 하다고 할 수있다.

반대로 사실적인 지형정보가 담겨있는 지도나 최초의 노선도에서는 
실제 승강장의 위치를 찾는데 도움을 받을 수 있다.

어떤 추상화도 의도된 목적대로 사용하지않는다면 오도될 수 있다. 
추상화의 수준,이익,가치는 목적에 의존적이다.
>현상은 복잡하다. 법칙은 단순하다. 버릴게 무엇인지 알아내라. 
> -리처드 파인만-

## 추상화에서 복잡도를 극복하는 방법

이 책에서 현실의 복잡함을 다루고 추상화 하는 방법을 두가지 차원으로 나누어 설명하고있다.

- 1.구체적 사물간 공통점은 취하고, 차이점은 버리는 일반화로 단순화.

- 2.중요한 부분을 강조하기 위한 불필요한 세부사항 제거로 단순화.

>사물에 대한 일반화와 불필요한 정보 제거로 단순화로 낮은 복잡성과 이해하기 쉬운 수준으로 만드는것이
추상화의 목적이다.

복잡함과 이해하기 어려운것은 두려움이 생기기 마련이다.
다음 예시로 추상화를 통한 단순화로 극복하는 과정을 알아보자.

    정원에 도착한 앨리스는 주변에서 깡총깡총 뛰어다니는 토끼와 
    하얀 장미나무를 빨갛게 칠하고 있는 트럼프 모양의 정원사들을 보았다.
    정원사들은 벌벌 떨면서 장미를 빨갛게 칠하고있었다.하얀장미로 잘못 심어
    여왕에게 들키면 곧장 목이 날아가게 생겼기 때문이다.
    잠시후 수많은 하객들과 하트가 그려진 여왕, 다이아몬드가 그려진 병사들이 정원에 들어섰다.
    정원사들은 벌벌떨었다. 하지만 앨리스는 괜찮아 기껏해야 트럼프에 불과해. 라며 두려워하지않았다.

앨리스는 토끼를 제외한 하객들과 정원사, 여왕과 병사들의 문양과 각자의 차이점은 모두 무시한채
트럼프카드 라는 하나의 공통점으로 단순화하고있다.

### 그룹으로 나누어 단순화

앞의 상황에서 결과적으로 앨리스는 정원에 있는 인물들을 두개의 그룹으로 나눈다.
토끼는 한마리 뿐이지만 개별적인 인물이 아닌 트럼프와 토끼라는 
두개의 렌즈를 통해 정원에 내재된 복잡성을 효과적으로 단순화한다.

개별적인 객체들을 그룹화로 분류하기 위해서는 **개념**이 필요하다.

앨리스의 경우에는 정원사,하객,여왕,병사의 공통점인 "트럼프카드" 가 일종의
객체를 그룹화 하는 개념이다

>객체는 개념을 표현하는 그룹의 일원이며, 그 개념집합의 일원일때 그 객체를 개념의 인스턴스 라고 한다.


### 개념의 관점 3가지

일반적인 객체의 분류장치로서 개념을 설명할때 세가지 관점을 언급한다

    심볼:개념을 가리키는 간략한명칭

[//]: # ()

    내연:개념의 완전한 정의,내연의 의미를 이용해 객체가 개념에 속하는지 여부를 확인할 수있다.

[//]: # ()

    외연:개념에 속하는 객체들의 집합

앨리스 이야기로 다시 설명하면 이렇게 쓸 수있다.

    심볼:트럼프

[//]: # ()

    내연:사각형 모양에 각 모서리에 팔다리가 달려있는 트럼프 카드모양 등장인물

[//]: # ()

    외연:정원사들,하객들,여왕,병사들

이렇게 개념을 이용해 객체를 그룹화 하는것을 분류 라고 하고,
객체에 특정 개념을 적용할때 우리는 그 객체를 특정그룹으로 분류하고 있다.

객체지향에서 분류는 프로그램에 많은 영향을 주며 적절한 개념으로 객체를 분류하면 
유지보수가 용이하고 변경에 유연한 애플리케이션을 만들 수 있다.

객체를 적절한 개념으로 분류하는것은 개발자에게 객체를 쉽게찾고 다루는 정신적 지도를 제공한다.

### 타입
객체의 행동에 따라 타입이 결정된다
객체의 타입은 내부의 표현과는 상관이없다. 내부 표현방식이 달라도 동일하게 행동하면 그 객체는 같은 타입에 속한다고 할 수 있다.

객체의 타입을 정하는 것은 행동이고, 어떤 데이터를 보유하는지는 타입결정에 영향이없다.


### 타입의 계층
일반화/특수화관계

앨리스 이야기에서 트럼프 인간은 포괄적인 트럼프 개념에서 좀더 특화된 행동을 하는 개념이다

일반화 특수화는 동시에 일어나며 트럼프 인간은 트럼프를 좀더 특수하게 표현 한것

객체지향에서 일반화/특수화 관계를 결정하는것은 객체의 행동이다


트럼프에 대한 행동을 추상화 하는 클래스를 만들어보자
```java
public abstract class Trump {
    public void Lying(){
        System.out.println("납작 엎드리기");
    }

    public void Flipping(){
        System.out.println("뒤집어지기");
    }
}
```

    트럼프 추상화 클래스에선 트럼프의 행동으로 트럼프에 대한 개념을 정의하고있다.

다음은 트럼프 개념을 상속받으면서 각각의 고유 행동을 하는 객체를 만들어보자
```java
public class TrumpBird extends Trump{

    @Override
    public void Lying() {
        super.Lying();
    }

    @Override
    public void Flipping() {
        super.Flipping();
    }

    public void flying(){
        System.out.println("펄럭펄럭");
    }
}

public class TrumpRabbit extends Trump{

    //Oevrride 생략

    public void jump(){
        System.out.println("깡총");
    }
}

public class TrumpHuman extends Trump{

    //Oevrride 생략
   
    public void say(){
        System.out.println("hi");
    }
}
```

이 세개의 객체bird,human,rabbit은 트럼프 라는 개념으로 일반화가 가능함과 동시에
각각의 고유한 행동 또한 가지고 있어 트럼프의 특수화 된 개념이라고 볼 수있다.

여기서 생각해 볼 것은 이렇게 개념의 특수화로 확장된 객체들의 메서드를 사용하려 할때
실행환경에서 수정,변경이 이루어지지 않으면서 확장된 객체들을 사용할 수 있어야한다. 그래야 
 유연한 애플리케이션을 만들 수 있다.


이 세개의 객체 또는 더 추가될지 모르는 트럼프 그룹의 객체들을 이용하여 다형성이 추가된 프로그램을 만들 수 있다.

```java
public class main {
    public static void main(String[] args) {

    Trump[] trumps = {new TrumpHuman(), new TrumpBird(), new TrumpRabbit()};
        for (Trump trump : trumps) {
            doSomething(trump);
        }
    }
    static void doSomething(Trump trump) {
        if (trump instanceof TrumpHuman human) {
            human.say();
        } else if (trump instanceof TrumpBird bird) {
            bird.flying();
        } else if (trump instanceof TrumpRabbit rabbit) {
            rabbit.jump();
        }
    }

}
```
위의 main 메서드에서 doSomeThing 메서드만을 이용해 확장된 Trump 객체들의 고유 메서드를 사용한다.

doSomeThing 메서드는 실행 환경에서 Trump를 상속받는 어떤 객체가 만들어졌을때 main 메서드의 코드가
그 객체의 메서드에 의존적이지 않도록 한다.

이렇게 하면 main 메서드에서 새롭게 확장된 객체가 만들어질 때마다 메시지를 변경할 필요없이 
확장된 Trump 객체를 받아 메서드를 실행하기 때문에 확장에 용이하다 볼 수 있으며,
ocp 원칙을 준수해 여러상황에 유동적으로 대처할 수 있는 애플리케이션을 만들 수 있게 된다.