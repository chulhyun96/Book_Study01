## 우리 모두를 합친 것보다 현명한 사람은 없다.

협력은 한사람이 다른 사람에데 도움을 요청할 때 시작된다.

밑에 재판 과정을 나타낸 요청과 응답의 사이클을 한번 봐보자.
- 누군가가 왕에게 재판을 요청
- 왕이 하안 토끼에게 증인을 부를 것을 요청
- 왕의 요청을 받은 토끼는 모자 장수에게 증인석으로 입장 요청
- 모자 장수는 증인석에 입장함으로써 토끼의 요청에 응답
- 모자 장수의 입장은 왕이 토끼에게 요청했던 증인 호출에 대한 응답이기도 하다
- 이제 왕은 모자 장수에게 증언할 것을 요청
- 모자 장수는자신이 알고 있는 내용을 증언함으로써 왕의 요청에 응답

훌룡한 객체를 설계하기 위해서는 먼저 협력이라는 단어 속에 내포된 다양한 특성을 두루 살펴볼 필요가 있다.

### 책임
객체지향 세계에서는 어떤 객체가 어떤 요청에 대해 대답해줄 수 있거나, 적절한 행동을 할 의무가 있는 경우 해당 객체가**책임**을 가진다고 말한다.

책임은 객체지향 설계의 가장 중요한 재료이며, 객체지향 개발에서 가장 중요한 능력은 책임을 능숙하게 소프트웨어 객체에 할당하는 것이라고 말한다.
책임을 어떻게 구현할 것인가 하는 문제는 객체와 책임이 제자리를 잡은 후에 고려해도 늦지 않다.

협력에 참여하는 객체들은 목표를 달성하는데 필요한 책임을 수행한다.
책임은 객체에 의해 정의되는 응집도 있는 행위의 집합으로, 객체가 알아야 하는 정보와 객체가 수행할 수 있는 해우이에 대해 개략적으로 서술한 문장이다.

즉 **객체의 책임은 '객체가 무엇을 알고 있는가와, 무엇을 할 수 있는가'로 구성된다.**
- 왕은 재판 집행이라는 책임을 수행하기 위해, 토끼에게 목격자를 불러오도록 요청, 목격자인 모자장수에게 증언하라고 요청
```java
public class King {
    public Witness callWitness(Rabbit rabbit) {
        return rabbit.comeIn();
    }

    public String tell(Witness witness) {
        return witness.tell();
    }
}
```


- 토끼는 목격자가 모자 장수라는 사실을 알고 있으며 동시에 모자 장수가 증인석에 입장하도록 요청
```java
public class Rabbit {
    private Witness witness;

    public Witness comeIn() {
        this.witness = new Witness();
        this.witness.walk();
        return this.witness;
    }
}
```

- 모자 장수의 경우 스스로 증인석에 입장해야 하는 책임과, 자신이 알고있는 사실을 증언해야 할 책임을 가지고 있다.
```java
public class Witness {
    public String tell() {
        return "내가 아는 모든 내용";
    }

    public void walk() {
        System.out.println("재판장으로 들어옵니다.");
    }
}

```

#### Main 
```java
public class Main {
    public static void main(String[] args) {
        King king = new King();
        Rabbit rabbit = new Rabbit();

        Witness witness = king.callWitness(rabbit);
        String result = king.tell(witness);
        System.out.println(result);
    }
}
```

### 객체의 모양을 결정하는 협력 
#### 흔한 오류
많은 사람들은 시스템에 필요한 데이터를 저장하기 위해 객체가 존재한다는 선입견을 가지고 있다.
물론 객체가 상태의 일부로 데이터를 포함하는 것은 사실이지만 데이터는 단지 객체가 행위를 수행하는데 필요한 재료일 뿐이다.

객체가 존재하는 이유는 행위를 수행하며 협력에 참여하기 위해서이다.

따라서 실제로 중요한 것은 객체의 행동, 즉 책임이다.

두번째 선입견은 객체지향이 클래스와 클래스간의 관계를 포함하는 시스템의 정적인 측면에 중점을 둔다는 것이다.
중요한 것은 정적인 클래스가 아니라 협력에 참여하는 동적인 객체이며, 클래스는 단지 시스템에 필요한 객체를 표현하고 생성하기 위해 프로그래밍 언어가 제공하는 기능중에 하나일 뿐이라는 것.

책에서 목격자가 계속해서 바뀐다. 해당 과정을 코드로 표현할 경우 Witness의 역할을 인터페이스로 두고, 적절한 Witness를 반환할
Factory 클래스를 두고 동적으로 각각 상황에 맞는 Witness를 꺼내 사용할 수도 있다.







