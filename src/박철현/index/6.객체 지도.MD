# 기능적이고 해결책 지향적인 접근 VS 구조적이고 문제 지향적인 접근

이번 챕터에서 다룰 내용의 핵심은 객체를 역할과, 기능으로 분리하여 협력을하는 객체지향 세계를 설명했다면, 이번 **챕터에서는 기능이 아닌 구조를 바탕으로 시스템을 분할하는 또 다른 측면을 제시한다.**

책의 화자는 누군가가 여행중에 다른 마을로 이동을 해야하는데, 길을 몰라서 물어보는 상황을 제시하며 시작한다.

여기에는 2가지 접근법이 존재한다고 한다.

1. 기능적이며 해결책 지향적인 접근법
해당 방식은 길을 가르쳐 주는 사람은 다른 마을 까지 가능 경로를 단계별로 상세히 설명해야 한다.
'**~~를 따라 ~Km 정도 직진하면 ~~가 나오는데 ~~... 등등**' 꽤나 친절하고 구체적으로 해당 마을을 가는 방식을 제시 한다.
- 해당 방식의 문제점은 일반적이지도 않으며 재사용 가능하지 않다.
- 강이나 산과같은 특정 건물, 추가적인 정보가 없다면 설명하기 어렵다

2. 구조적이고 문제 지향적인 접근법
해당 방식은 '**지도**'를 이용하는 것이다.
지도는 길을 찾는데 필요한 구체적인 기능이 아니라 길을 찾을 수 있는 '**구조**'를 제시한다.

지도를 이용해 길을 찾는 방식은 다양한 목적을 위해 **재사용**될 수 있을 뿐더러(범용적이다.), 사용의도와 맞게 구체적인 방법또한 제시한다.
그리고 지도를 이용하는 방식은 사용자들의 요구사항에 맞게 다양하게 대처할 수 있다는 것이다.

즉 여기서의 핵심은 **구조를 기반으로 모델을 구축하는 것**이 범용적이고, 이해하기 쉬우며 변경에 안정적이라는 것이다.
그리고 객체지향은 자주 변경되는 기능이 아니라 안정적인 구조를 기반으로 시스템을 구조화 한다.

앞선 챕터들에서는 객체지향을 역할과 책임을 수행하며 협력하는 자율적인 객체들의 공동체로 정의 했다.

자율적인 객체들로 시스템을 분할하는 **객체지향이 강력한 이유는 사람들이 실세계의 현상을 인지하고 이해하는 관점을 그대로 소프트웨어에 투영 할 수 있기 때문이다.**

#### 기능 설계 VS 구조 설계
모든 소프트웨어 제품의 설계에는 두 가지 측면이 존재한다.

하나는 '기능 측면 설계', 또 다른 하나는 '구조 측면 설계' 이다.

1. 기능 측면 설계
해당 설계 방식은 제품이 사용자를 위해 무엇을 할 수 있는가에 초점을 맞춘 방식이다.


2. 구조 측면 설계
해당 설계 방식은 제품의 형태가 어떠해야 하는지에 초점을 맞춘다.


두 가지 측면을 함께 녹여 조화를 이루도록 만드는 것이다.

훌룡한 기능은 소프트웨어를 만드는 충분 조건이라면, **훌륭한 구조는 소프트웨어를 만들기 위한 필수 조건이다.**

위에서 길을 묻는 상황을 제시하며 이번 챕터를 이야기한 화자는 위의 내용을 설명하면서 강조하는 것이 있다.

바로 **구조적인 설계** 부분이다.

위에서는 '지도'가 구조적인 설계에 해당했다. 

이는 클라이언트의 요청의 항시 변하는 요구사항에 맞게 지도는 그 요구사항을 호환하고, 범용성이 높으며, 안정적이다.

그에 맞게, 여기서도 다시한번 언급한다. '**소프트 웨어의 세계에서 변하지 않는 유일한 규칙은 요구사항이 항상 변경된다는 것.**'

설계가 어려운 이유는 어제 약속했던 기능을 제공하는 동시에 내일 변경될지도 모르는 요구사항도 수용할 수 있는 코드를 창조해야 하기 때문이다.


미래의 변경에 대비할 수는 있지만 미래의 변경을 예측하는 것은 불가능이다.

이부분은 받아들여야 한다. 나는 미래를 예측하고 코드를 작성할 수 없다. 미래를 예측한다고 해서, 해당 소프트웨어의 수명이 다할 때 마지막 클라이언트의 요청까지 예측할 수 없다.

**그렇다면 우리는 어떤 방식으로 코드를 작성해야 하는가???**

>미래에 대비하는 가장 좋은 방법은 변경을 예측하는 것이 아니라 변경을 수용할 수 있는 선택의 여지를 설계에 마련해 놓는 것이다.
> 훌륭한 설계자는 미레에 구체적으로 어떠한 변경이 발생할 것인지를 예측하지 않는다. 단지 언젠가는 변경이 발생할 것이며 아직까지는 그것이 무엇인지 모른다는 사실을 받아들인다.

좋은 설계는 나중에라도 변경할 수 있는 여지를 남겨놓는 설계인 것이다.

**설계를 하는 목적은 나중에 설계를 허용하는 것이며, 설계의 일차적인 목표는 변경에 소요되는 비용**을 낮추는 것이다.

#### 기능과 구조
그렇다면 소프트웨어에서 말하는 기능과 구조는 정확히 무엇을 의미하는 걸까?
객체지향 세계를 구축하기 위해서는 사용자에게 제공할 '기능', 그리고 기능을 담을 안정적인 '구조'라는 재료가 필요하다.

즉 **기능은 사용자에게 제공할 서비스.**, 그리고 그 **서비스를 담은 안정적인 그릇이 '구조'라는 것**이다.


#### 도메인의 모습을 담을 수 있는 객체지향

소프트웨어의 최종 제품은 사용자의 관점을 반영해야 한다는 것이다.

즉 최종 코드의 형태는 사용자가 도메인을 바라보는 관점을 반영해야 하는 것이며, 이것은 곧 애플리케이션이 도메인 모델을 기반으로 설계되어야 하는 것을 의미한다.

도메인 모델이란 사용자들이 도메인을 바라보는 관점이며, 설계자가 시스템의 구조를 바라보는 관점인 동시에 소프트웨어안에 구현된 코드의 모습 그 자체이기 때문이다.

객체지향을 사용하면 사용자들이 이해하고 있는 도메인의 구조와 최대한 유사하게 코드를 구조화 할 수 있다.

```java
import java.time.LocalDate;
import java.util.Date;

class 정기예금 {
    private Date date;
    private boolean isCancel;
    //... 생략
    
}

class 계좌 {
    private int accountNumber;
    private int credit;
    //... 생략
}

class 이자 {
    private int credit;
    private Date paymentDate;
    //... 생략
}

```

표현적 차이가 중요한 이유는 소프트웨어를 이해하고 수정하기 쉽게 만들어 주기 때문이다.

그리고 이러한 표현적 차이를 잘 분석해서 도메인 객체를 잘 설계하는 것이 비교적 변경될 확률이 적은 코드를 작성하는 방식과도 연결된다.

**최종 코드의 형태는 사용자 측면에서 작성되어야 한다는 것이, 핵심이다.**

해당 예제 코드에서 사람들이 정기예금에 관해 생각하는 개념과 규칙을 모두 포함하고 있다. 

정기예금을 가입하는 예금주나 은행업무를 담당하는 도메인 전문가 들은 모델을 구성하는 각 요소의 의미와 관계를 쉽게 파악할 수 있을 것이다.

그리고 가장 중요한 것은 해당 모델링이 안정적이라는 것이다. 

해당 모델에서 사용하고 있는 개념의 정의와 속성은 은행 업무에서 다뤄지는 정기예금의 정의가 변경되지 않는 한 쉽게 바뀌지 않을 것이다.

**정리**
이번 챕터에 대한 내용은 객체지향 설계 방식을 기반으로, 기능적인 측면에서 구조적인 측면을 제시하며 여러가지 이점을 제시한다.
그리고 구조적인 측면이란 객체지향 설계 방식을 따르면 자동적으로 지켜지는 것들이였다. 유스케이스 또한 책임 - 주도 설계 방식으로 설계를 할 경우 모두 통합이 되는 내용들이었다.

그리고 도메인 모델링을 하면서 결국에는 **사용자가 생각하는 제품의 모습과, 코드로 반영되어야 하는 모습이 같다는 것**.








