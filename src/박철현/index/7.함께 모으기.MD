# 코드와 모델을 밀접가게 연관시키는 것은 코드에 의미를 부여하고, 모델을 적절하게 한다.


책의 저자는 마틴 파울러의 UML Distilled2판에서 나온 객체지향 설계 안에 존재하는 세가지 상호 연관된 관점에 관해 설명한다.

1. 개념관점
2. 명세관점
3. 구현 관점


#### 개념관점
개념관점 설계는 개념과 개념들 사이의 관계를 표현하며, 도메인이란 사용자들이 관심을 가지고 특정 분야나 주제를 말한다.

소프트 웨어는 도메인에 존재하는 문제를 해결하기 위해 개발되며, 이 관점은 사용자가 도메인을 바라보는 관점을 반영하는 것이다.

#### 명세관점
명세 관점은 사용자의 관심영역인 도메인에서 벗어나 개발자의 영역인 소프트웨어로 초점이 옮겨진다. 실제로 소프트웨어에서 살아 숨쉬는 객체들의 책임에 초점을 맞추게 된다.

즉, **객체들의 인터페이스를 바라보게 된다.**

명세관점은 객체들이 '무엇'을 할 수 있는가에 초점을 맞춘 것이다.

#### 구현관점

구현관점은 프로그래머가 가장 익숙한 관점으로 실제 작업을 수행하는 코드와 연관되어 있다.

구현 관점의 초점은 객체들이 책임을 수행하는데 필요한 동작학하는 코드를 작성하는 것이다.

따라서 스포르개머는 객체의 책임을 '어떻게' 수행할 것인가에 초점을 맞추며 인터페이스를 구현하는데 필요한 속성과 메서드를 클래스에 추가한다.

-----

앞서 본 위의 관점들을 기준으로 설계를 하는 것이 아니라, 하나의 클래스를 세 가지 다른 방향에서 바라보는 것을 의미한다.

클래스가 은유 하는 개념(역할)은 도메인 관점을 반영하며, 클래스의 공용 인터페이스는 명세 관점을, 클래스의 속성과 메서드는 구현 관점을 반영한다.


#### 커피 전문점 도메인으로 알아보기
커피 전문점이라는 세상에는 메뉴가 적인 메뉴판과, 손님, 바리스타 들이 존재한다.

손님은 메뉴판을 보고 바리스타에게 원하는 커피를 주문한다. 바리스타는 주문을 받은 메뉴에 따라 커피를 제조한다.

1. 손님은 메뉴를 주문하기 위해 어떤 식으로든 메뉴판을 알아야 할 것이다. 이 뜻은 두 객체 사이에 관계가 존재한다는 것이다.

2. 손님은 바리스타에게 주문을 해야 한다. 손님과 바리스타 사이에도 관계가 존재한다.

3. 바리스타는 커피를 제조하므로 자신이 만든 커피와 관계가 존재한다.

#### 설계하고 구현하기
이제 커피를 주문하기 위해서 협력 관계를 찾아보자.

위에서 보았듯이 커피 전문점 도메인을 바탕으로 우리는 손님, 메뉴판, 메뉴, 바리스타가 필요하다는 것을 알았다.

```java
class Customer {
    public void order(String menuName, Menu menu, Barista barista) {
        MenuItem menuItem = menu.choose(menuName);
        Coffee coffee = barista.makeCoffee(menuItem);
        //...
    }
}

class Menu {
    private List<MenuItem> items;

    public Menu(List<MenuItem> items) {
        this.items = items;
    }

    public MenuItem choose(String name) {
        for (MenuItem item : items) {
            if (item.getNaem().eqauls(name)) {
                return item;
            }
        }
        return null;
    }
}

class Barista {
    public Coffee makeCoffee(MenuItem menuItem) {
        return new Coffee(menuItem);
    }
}

class Coffee {
    private String name;
    private int price;

    public Coffee(MenuItem menuItem) {
        this.name = menuItem.getName();
        this.price = menuItem.cost();
    }
}
class MenuItem {
    private String name;
    private String price;
    
    public MenuItem(String name, int price) {
        this.name = name;
        this.price = price;
        
    }
    public int cost() {
        return price;
    }
    public String getName() {
        return name;
    }
}
```

#### 세가지 관점 적용하기
앞에서 작성한 코드는 개념, 명세, 구현관점에서 각기 다른 사항들을 설명해준다.

먼저 **개념관점**에서 코드를 바라보면 해당 클래스들은 커피 전문점 도메인을 구성하는 중요한 개념과 관계를 반영한다는 사실을 쉽게 알 수 있다.
소프트웨어 클래스가 도메인 개념의 특성을 최대한 수용하면 변경을 관리하기 쉽고 유지 보수성을 향상 시킬 수 있다.

예를 들어 커피를 제조하는 과정을 변경해야 한다면 어디를 수정해야 할까?
도메인 관점에서 커피를 제조하는 과정은 바리스타가 변경해야 한다.

소프트웨어 관점에서도 마찬가지이다. 바리스타라는 클래스가 커피를 제조할 것이라고 쉽게 유추할 수 있다.

소프트웨어 클래스와 도메인 클래스 사이의 간격이 좁으면 좁을수록 기능을 변경하기 위해 뒤적거려야 하는 코드의 양도 점점 줄어든다.

**명세 관점**은 클래스의 인터페이스를 바라본다.
클래스의 `public`메서드는 다른 클래스가 협력할 수 있는 공용 인터페이스를 드러낸다.

공용 인터페이스는 외부의 객체가 해당 객체에 접근할 수 있는 유일한 부분이다.
인터페이스 수정 시 해당 객체와 협력하는 모든 객체에게 영향을 미칠 수 밖에 없다.

**객체의 인터페이스는 수정하기 어렵다는 것을 명심하라.**

**구현 관점**은 클래스의 내부 구현을 바라본다. 클래스의 메서드와 속성은 구현에 속하며 공용 인터페이스의 일부강 ㅏ니다.

따라서 메서드의 구현과 속성의 변경은 구현에 속하며 공용 인터페이스의 일부가 아니다.
메서드의 구현과 속성의 변경은 원칙적으로 외부의 객체에게 영향을 미쳐서는 안된다.


#### 핵심내용
위 설명의 핵심내용을 종합하자면, 인터페이스와 구현을 분리하는 것이다.

명세 관점은 클래스의 안정적인 측면을 드러내야 하며, 구현 관점은 클래스의 불안정한 측면을 드러내는 것이다.

인터페이스가 구현 세부 사항을 노출하기 시작하면 아주 작은 변동에도 전체 협력이 요동치는 취약한 설계를 얻을 수 밖에 없다.

마틴 파울러는 개념적인 관점과 명세 관점 사이는 중요하지 않은 경우가 많다고 하지만, 명세 관점과 구현 관점을 분리하는 것은 매우 중요하다고 주장한다.

프로그래머의 입장에서 가장 많이 접하게 되는 것은 코드이며 구현관점을 가장 빈번하게 사용하겠지만, 실제로 훌룡한 설계를 결정하는 측면은 명세관점인 객체의 인터페이스이다.

명세관점이 설계를 주도하면 설계의 품질이 향상 될 수 있다는 사실을 기억하자.

**요약**

**개념 관점**: 클래스가 도메인 개념과 잘 맞아떨어지면 유지보수가 쉽다. 커피 제조 과정은 Barista 클래스가 담당한다.

**명세 관점**: 클래스의 public 메서드는 다른 클래스가 협력하는 인터페이스이다. 이 인터페이스는 수정하기 어렵다.

**구현 관점**: 클래스의 내부 구현은 외부에 영향을 미치지 않으며, 내부적으로 자유롭게 변경 가능해야한다 .

그리고 설계시 하나의 클래스를 만들더라도 이러한 세가지 관점을 유의하며 만들어야 한다. 


